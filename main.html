<!DOCTYPE html>
<html>

  <head>
    <title>model 3d</title>
    <meta charset="utf-8"/>


    <script src="src/js/m3dObject.js"></script>

    <!-- math -->
    <script src="src/js/math/m3dMath.js"></script>
    <script src="src/js/math/m3dVector2d.js"></script>
    <script src="src/js/math/m3dVector3d.js"></script>
    <script src="src/js/math/m3dVector4d.js"></script>
    <script src="src/js/math/m3dMatrix2d.js"></script>
    <script src="src/js/math/m3dMatrix3d.js"></script>
    <script src="src/js/math/m3dMatrix4d.js"></script>
    <script src="src/js/math/m3dRotMatrix2d.js"></script>
    <script src="src/js/math/m3dPerspectiveProjection.js"></script>
    <script src="src/js/math/m3dTranslationMatrix4d.js"></script>
    <script src="src/js/math/m3dRotationMatrix4d.js"></script>

    <!-- gfx -->
    <script src="src/js/gfx/m3dGfx.js"></script>
    <script src="src/js/gfx/m3dSurface.js"></script>
    <script src="src/js/gfx/m3dDrawable.js"></script>
    <script src="src/js/gfx/m3dPixel.js"></script>
    <script src="src/js/gfx/m3dLine.js"></script>
    <script src="src/js/gfx/m3dCamera.js"></script>

    <script>
      window.addEventListener("load",
        () => { // main -->

          let cfg = {
            fps: 60,
            surface: { w: 800, h: 600 }
          }
          let surface = new M3dSurface(cfg)

          let myVector4dA = new M3dVector4d(1.0, 1.0, -1.0, 1)
          let myVector4dB = new M3dVector4d(1.0, -1.0, -1.0, 1)

          let myVector4dC = new M3dVector4d(1.0, 1.0, 1.0, 1)
          let myVector4dD = new M3dVector4d(1.0, -1.0, 1.0, 1)

          let myVector4dE = new M3dVector4d(-1.0, 1.0, -1.0, 1)
          let myVector4dF = new M3dVector4d(-1.0, -1.0, -1.0, 1)

          let myVector4dG = new M3dVector4d(-1.0, 1.0, 1.0, 1)
          let myVector4dH = new M3dVector4d(-1.0, -1.0, 1.0, 1)


          let camera = new M3dCamera()
          let myTranslationMatrix = new M3dTranslationMatrix4d(-2.4, 1.8, 0)
          let myPerspectiveProjection = new M3dPerspectiveProjection()
          let myRotationX = new M3dRotationMatrix4d('x', 0)
          let myRotationY = new M3dRotationMatrix4d('y', 0)
          let myRotationZ = new M3dRotationMatrix4d('z', 0)
          // let pointA = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dA))))
          // let pointB = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dB))))
          // let pointC = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dC))))
          // let pointD = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dD))))
          // let pointE = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dE))))
          // let pointF = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dF))))
          // let pointG = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dG))))
          // let pointH = camera.translation.multiply(camera.orientation.multiply(myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dH))))

          let pointA = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dA))
          let pointB = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dB))
          let pointC = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dC))
          let pointD = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dD))
          let pointE = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dE))
          let pointF = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dF))
          let pointG = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dG))
          let pointH = myTranslationMatrix.multiply(myPerspectiveProjection.multiply(myVector4dH))

          let myLineAB = new M3dLine(new M3dVector2d(myVector4dA.x, myVector4dA.y), new M3dVector2d(myVector4dB.x, myVector4dB.y), '#00ff00')
          let myLineAC = new M3dLine(new M3dVector2d(myVector4dA.x, myVector4dA.y), new M3dVector2d(myVector4dC.x, myVector4dC.y), '#00ff00')
          let myLineBD = new M3dLine(new M3dVector2d(myVector4dB.x, myVector4dB.y), new M3dVector2d(myVector4dD.x, myVector4dD.y), '#00ff00')
          let myLineCD = new M3dLine(new M3dVector2d(myVector4dC.x, myVector4dC.y), new M3dVector2d(myVector4dD.x, myVector4dD.y), '#00ff00')
          let myLineEF = new M3dLine(new M3dVector2d(myVector4dE.x, myVector4dE.y), new M3dVector2d(myVector4dF.x, myVector4dF.y), '#00ff00')
          let myLineEG = new M3dLine(new M3dVector2d(myVector4dE.x, myVector4dE.y), new M3dVector2d(myVector4dG.x, myVector4dG.y), '#00ff00')
          let myLineFH = new M3dLine(new M3dVector2d(myVector4dF.x, myVector4dF.y), new M3dVector2d(myVector4dH.x, myVector4dH.y), '#00ff00')
          let myLineGH = new M3dLine(new M3dVector2d(myVector4dG.x, myVector4dG.y), new M3dVector2d(myVector4dH.x, myVector4dH.y), '#00ff00')
          

          let my3dLineAB = new M3dLine(new M3dVector2d(pointA.x / pointA.z, pointA.y / pointA.z), new M3dVector2d(pointB.x / pointB.z, pointB.y / pointB.z), '#00ff00')
          let my3dLineAC = new M3dLine(new M3dVector2d(pointA.x / pointA.z, pointA.y / pointA.z), new M3dVector2d(pointC.x / pointC.z, pointC.y / pointC.z), '#00ff00')
          let my3dLineBD = new M3dLine(new M3dVector2d(pointB.x / pointB.z, pointB.y / pointB.z), new M3dVector2d(pointD.x / pointD.z, pointD.y / pointD.z), '#00ff00')
          let my3dLineCD = new M3dLine(new M3dVector2d(pointC.x / pointC.z, pointC.y / pointC.z), new M3dVector2d(pointD.x / pointD.z, pointD.y / pointD.z), '#00ff00')
          
          let my3dLineEF = new M3dLine(new M3dVector2d(pointE.x / pointE.z, pointE.y / pointE.z), new M3dVector2d(pointF.x / pointF.z, pointF.y / pointF.z), '#00ff00')
          let my3dLineEG = new M3dLine(new M3dVector2d(pointE.x / pointE.z, pointE.y / pointE.z), new M3dVector2d(pointG.x / pointG.z, pointG.y / pointG.z), '#00ff00')
          let my3dLineFH = new M3dLine(new M3dVector2d(pointF.x / pointF.z, pointF.y / pointF.z), new M3dVector2d(pointH.x / pointH.z, pointH.y / pointH.z), '#00ff00')
          let my3dLineGH = new M3dLine(new M3dVector2d(pointG.x / pointG.z, pointG.y / pointG.z), new M3dVector2d(pointH.x / pointH.z, pointH.y / pointH.z), '#00ff00')
          
          let my3dLineAE = new M3dLine(new M3dVector2d(pointA.x / pointA.z, pointA.y / pointA.z), new M3dVector2d(pointE.x / pointE.z, pointE.y / pointE.z), '#00ff00')
          let my3dLineBF = new M3dLine(new M3dVector2d(pointB.x / pointB.z, pointB.y / pointB.z), new M3dVector2d(pointF.x / pointF.z, pointF.y / pointF.z), '#00ff00')
          let my3dLineCG = new M3dLine(new M3dVector2d(pointC.x / pointC.z, pointC.y / pointC.z), new M3dVector2d(pointG.x / pointG.z, pointG.y / pointG.z), '#00ff00')
          let my3dLineDH = new M3dLine(new M3dVector2d(pointD.x / pointD.z, pointD.y / pointD.z), new M3dVector2d(pointH.x / pointH.z, pointH.y / pointH.z), '#00ff00')

          // surface.addDrawable(myLineAB)
          surface.addDrawable(my3dLineAB)

          // surface.addDrawable(myLineAC)
          surface.addDrawable(my3dLineAC)

          // surface.addDrawable(myLineCD)
          surface.addDrawable(my3dLineCD)

          // surface.addDrawable(myLineBD)
          surface.addDrawable(my3dLineBD)

          // surface.addDrawable(myLineEF)
          surface.addDrawable(my3dLineEF)

          // surface.addDrawable(myLineEG)
          surface.addDrawable(my3dLineEG)

          // surface.addDrawable(myLineFH)
          surface.addDrawable(my3dLineFH)

          // surface.addDrawable(myLineGH)
          surface.addDrawable(my3dLineGH)

          // surface.addDrawable(myLineAE)
          surface.addDrawable(my3dLineAE)

          // surface.addDrawable(myLineBF)
          surface.addDrawable(my3dLineBF)

          // surface.addDrawable(myLineCG)
          surface.addDrawable(my3dLineCG)

          // surface.addDrawable(myLineDH)
          surface.addDrawable(my3dLineDH)

          camera.update = () => {
            myRotationZ.rotate(0.005)
            myRotationY.rotate(0.006)
            myRotationX.rotate(0.007)

            pointA = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dA)))))))
            pointB = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dB)))))))
            pointC = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dC)))))))
            pointD = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dD)))))))
            pointE = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dE)))))))
            pointF = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dF)))))))
            pointG = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dG)))))))
            pointH = camera.translation.multiply(camera.orientation.multiply(myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dH)))))))

            // pointA = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dA)))))
            // pointB = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dB)))))
            // pointC = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dC)))))
            // pointD = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dD)))))
            // pointE = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dE)))))
            // pointF = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dF)))))
            // pointG = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dG)))))
            // pointH = myPerspectiveProjection.multiply(myTranslationMatrix.multiply(myRotationX.multiply(myRotationY.multiply(myRotationZ.multiply(myVector4dH)))))
            // console.log(pointA, pointB)
            my3dLineAB = my3dLineAB.set(pointA.x / pointA.z, pointA.y / pointA.z, pointB.x / pointB.z, pointB.y / pointB.z)
            my3dLineAC = my3dLineAC.set(pointA.x / pointA.z, pointA.y / pointA.z, pointC.x / pointC.z, pointC.y / pointC.z)
            my3dLineBD = my3dLineBD.set(pointB.x / pointB.z, pointB.y / pointB.z, pointD.x / pointD.z, pointD.y / pointD.z)
            my3dLineCD = my3dLineCD.set(pointC.x / pointC.z, pointC.y / pointC.z, pointD.x / pointD.z, pointD.y / pointD.z)
            my3dLineEF = my3dLineEF.set(pointE.x / pointE.z, pointE.y / pointE.z, pointF.x / pointF.z, pointF.y / pointF.z)
            my3dLineEG = my3dLineEG.set(pointE.x / pointE.z, pointE.y / pointE.z, pointG.x / pointG.z, pointG.y / pointG.z)
            my3dLineFH = my3dLineFH.set(pointF.x / pointF.z, pointF.y / pointF.z, pointH.x / pointH.z, pointH.y / pointH.z)
            my3dLineGH = my3dLineGH.set(pointG.x / pointG.z, pointG.y / pointG.z, pointH.x / pointH.z, pointH.y / pointH.z)
            my3dLineAE = my3dLineAE.set(pointA.x / pointA.z, pointA.y / pointA.z, pointE.x / pointE.z, pointE.y / pointE.z)
            my3dLineBF = my3dLineBF.set(pointB.x / pointB.z, pointB.y / pointB.z, pointF.x / pointF.z, pointF.y / pointF.z)
            my3dLineCG = my3dLineCG.set(pointC.x / pointC.z, pointC.y / pointC.z, pointG.x / pointG.z, pointG.y / pointG.z)
            my3dLineDH = my3dLineDH.set(pointD.x / pointD.z, pointD.y / pointD.z, pointH.x / pointH.z, pointH.y / pointH.z)
          }

          surface.addUpdateable(camera)

          
          // let myPixel = new M3dPixel(new M3dVector2d(100, 100), '#00ff00')
          // let myLine = new M3dLine(new M3dVector2d(100, 100), new M3dVector2d(500, 500), '#00ff00')
          // surface.addDrawable(myPixel)
          // surface.addDrawable(myLine)

          // let myMatrix2d = new M3dMatrix2d(
          //   new M3dVector2d(1, 3),
          //   new M3dVector2d(2, 4)
          // )
          
          // let myMatrix3d = new M3dMatrix3d(
          //   new M3dVector3d(1, 4, 7),
          //   new M3dVector3d(2, 5, 8),
          //   new M3dVector3d(3, 6, 9)
          // )
          
          // let newMatrix2D = myMatrix2d.multiply(new M3dMatrix2d(new M3dVector2d(5, 7), new M3dVector2d(6, 8)))
          // let newVector2D = myMatrix2d.multiply(new M3dVector2d(3, 4))

          // let newMatrix3D = myMatrix3d.multiply(new M3dMatrix3d(
          //   new M3dVector3d(10, 13, 16),
          //   new M3dVector3d(11, 14, 17),
          //   new M3dVector3d(12, 15, 18)
          // ))
          // let newVector3D = myMatrix3d.multiply(new M3dVector3d(3, 4, 5))
          
          // myLine.update = () => {
          //   myLine.rotate(0.01)
          // }
          // console.log(myMatrix2d)
          // console.log(myMatrix2d.transpose())
        } // <-- main
      )
    </script>
  </head>

  <body>
    <div>
      <canvas id="renderSurface">
      </canvas>
    </div>
  </body>

</html> 